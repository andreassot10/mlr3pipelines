% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PipeOpTrafo.R
\name{PipeOpTargetTrafo}
\alias{PipeOpTargetTrafo}
\title{PipeOpTargetTrafo}
\format{
Abstract \code{\link{R6Class}} inheriting from \code{\link{PipeOp}}.
}
\description{
Base class for handling target transformation operations that have to be inverted later. The
target is transformed during the training phase and information to invert this transformation can
be send along to \code{\link{PipeOpTargetInverter}} which then inverts this transformation during the
prediction phase. This inversion may need info about both the training and the prediction data.

Users should overload four functions:
\itemize{
\item \code{set_state()} has a \code{\link[mlr3:Task]{Task}} input and should return a \code{list}, which can be used to
set the \verb{$state}. \code{set_state()} will be called a single time during training right before
\code{train_target()} will be called. Therefore, the \verb{$state} may contain info needed in
\code{train_target()}.
\item \code{train_target()} has a \code{\link[mlr3:Task]{Task}} input and should return a modified
\code{\link[mlr3:Task]{Task}}. This typically consists of calculating a new target and modifying the
task by using \code{private$.update_target()}. \code{train_target()} will be called during training and
prediction because the target (and if needed also type) of the input task must be transformed
both times.
\item \code{train_invert()}has a \code{\link[mlr3:Task]{Task}} input and should return a \code{predict_phase_control}
object (can be anything the user needs for the inversion later). This should not modify the input
task.
\item \code{inverter()} has a \code{\link[mlr3:Prediction]{Prediction}} input as well as one for a
\code{predict_phase_control} object and should return a function that can later be used to invert the
transformation done by \code{train_target()} and return a \code{\link[mlr3:Prediction]{Prediction}} object.
}
}
\section{Construction}{
\preformatted{PipeOpTargetTrafo$new(id, param_set = ParamSet$new(),
  param_vals = list(), packages = character(0))
}
\itemize{
\item \code{id} :: \code{character(1)}\cr
Identifier of resulting object. See \verb{$id} slot of \code{\link{PipeOp}}.
\item \code{param_set} :: \code{\link[paradox:ParamSet]{ParamSet}}\cr
Parameter space description. This should be created by the subclass and given to
\code{super$initialize()}.
\item \code{param_vals} :: named \code{list}\cr
List of hyperparameter settings, overwriting the hyperparameter settings given in \code{param_set}.
The subclass should have its own \code{param_vals} parameter and pass it on to \code{super$initialize()}.
Default \code{list()}.
\item packages :: \code{character}\cr
Set of all required packages for the \code{\link{PipeOp}}'s methods. See \verb{$packages} slot. Default is
\code{character(0)}.
}
}

\section{Input and Output Channels}{

\code{\link{PipeOpTargetTrafo}} has one input channels named \code{"input"} taking a \code{\link[mlr3:Task]{Task}} both
during training and prediction.

\code{\link{PipeOpTargetTrafo}} has two output channels named \code{"fun"} and \code{"output"}. During training,
\code{"fun"} returns \code{NULL} and during prediction, \code{"fun"} returns a function that can later be used
to invert the transformation done during training according to the overloaded \code{train_invert()}
and \code{inverter()} functions. \code{"output"} returns the modified input \code{\link[mlr3:Task]{Task}} according
to the overloaded \code{train_target()} function both during training and prediction.
}

\section{State}{

The \verb{$state} is a named \code{list} and should be returned explicitly by the user in the overloaded
\code{set_state()} function.
}

\section{Internals}{

\code{\link{PipeOpTargetTrafo}} is an abstract class inheriting from \code{\link{PipeOp}}. It implements the
\code{private$.train()} and \code{private$.predict()} functions. These functions perform checks and go on
to call \code{set_state()}, \code{train_target()}, \code{train_invert()} and \code{inverter()}. A subclass of
\code{\link{PipeOpTargetTrafo}} should implement these functions and be used in combination with
\code{\link{PipeOpTargetInverter}}.
}

\section{Fields}{

Fields inherited from \code{\link{PipeOp}}.
}

\section{Methods}{

Methods inherited from \code{\link{PipeOp}}, as well as:
\itemize{
\item \code{set_state(task)}\cr
(\code{\link[mlr3:Task]{Task}}) -> \code{list}\cr
Called by \code{\link{PipeOpTargetTrafo}}'s implementation of \code{private$.train()}. Takes a single
\code{\link[mlr3:Task]{Task}} as input and returns a \code{list} to set the \verb{$state}. Can be \code{list()}.
\item \code{train_target(task)}\cr
(\code{\link[mlr3:Task]{Task}}) -> \code{\link[mlr3:Task]{Task}}\cr
Called by \code{\link{PipeOpTargetTrafo}}'s implementation of \code{private$.train()} and
\code{private$.predict()}. Takes a single \code{\link[mlr3:Task]{Task}} as input and modifies it. Note that
unlike \verb{$.train()}, the argument is \emph{not} a list but a singular \code{\link[mlr3:Task]{Task}}, and the
return object is also \emph{not} a list but a singular \code{\link[mlr3:Task]{Task}}.
\item \code{train_invert(task)}\cr
(\code{\link[mlr3:Task]{Task}}) -> \code{predict_phase_control} object\cr
Called by \code{\link{PipeOpTargetTrafo}}'s implementation of \code{private$.predict()}. Takes a single
\code{\link[mlr3:Task]{Task}} as input and returns a \code{predict_phase_control} object (can be anything the
user needs for the inversion later). This should not modify the input task.
\item \code{inverter(prediction, predict_phase_control)}\cr
(\code{\link[mlr3:Prediction]{Prediction}}, \code{predict_phase_control} object) -> \code{function}\cr
Called by \code{private$.invert_help()} within \code{\link{PipeOpTargetTrafo}}'s implementation of
\code{private$.predict()}. Takes a \code{\link[mlr3:Prediction]{Prediction}} and a \code{predict_phase_control}
object as input and returns a function that can later be used for the inversion.
\item \code{.update_target(task, new_target, new_type = NULL, ...)}\cr
(\code{\link[mlr3:Task]{Task}}, new_target, new_type, ...) -> \code{\link[mlr3:Task]{Task}}\cr
Typically called within \code{train_target()}. Updates the target of a task and also the task_type
(if needed). Internally uses \code{convert_task()} and drops the original target from the task.
\item \code{.invert_help(predict_phase_control)}\cr
(\code{predict_phase_control} object) -> \code{function}\cr
Helper function that returns a function that can later be used for the inversion.
}
}

\seealso{
Other mlr3pipelines backend related: 
\code{\link{Graph}},
\code{\link{PipeOpTaskPreprocSimple}},
\code{\link{PipeOpTaskPreproc}},
\code{\link{PipeOp}},
\code{\link{mlr_graphs}},
\code{\link{mlr_pipeops_updatetarget}},
\code{\link{mlr_pipeops}}

Other PipeOps: 
\code{\link{PipeOpEnsemble}},
\code{\link{PipeOpImpute}},
\code{\link{PipeOpProxy}},
\code{\link{PipeOpTaskPreproc}},
\code{\link{PipeOp}},
\code{\link{mlr_pipeops_boxcox}},
\code{\link{mlr_pipeops_branch}},
\code{\link{mlr_pipeops_chunk}},
\code{\link{mlr_pipeops_classbalancing}},
\code{\link{mlr_pipeops_classifavg}},
\code{\link{mlr_pipeops_classweights}},
\code{\link{mlr_pipeops_colapply}},
\code{\link{mlr_pipeops_collapsefactors}},
\code{\link{mlr_pipeops_copy}},
\code{\link{mlr_pipeops_datefeatures}},
\code{\link{mlr_pipeops_encodeimpact}},
\code{\link{mlr_pipeops_encodelmer}},
\code{\link{mlr_pipeops_encode}},
\code{\link{mlr_pipeops_featureunion}},
\code{\link{mlr_pipeops_filter}},
\code{\link{mlr_pipeops_fixfactors}},
\code{\link{mlr_pipeops_histbin}},
\code{\link{mlr_pipeops_ica}},
\code{\link{mlr_pipeops_imputehist}},
\code{\link{mlr_pipeops_imputemean}},
\code{\link{mlr_pipeops_imputemedian}},
\code{\link{mlr_pipeops_imputemode}},
\code{\link{mlr_pipeops_imputenewlvl}},
\code{\link{mlr_pipeops_imputesample}},
\code{\link{mlr_pipeops_kernelpca}},
\code{\link{mlr_pipeops_learner}},
\code{\link{mlr_pipeops_missind}},
\code{\link{mlr_pipeops_modelmatrix}},
\code{\link{mlr_pipeops_mutate}},
\code{\link{mlr_pipeops_nop}},
\code{\link{mlr_pipeops_pca}},
\code{\link{mlr_pipeops_quantilebin}},
\code{\link{mlr_pipeops_regravg}},
\code{\link{mlr_pipeops_removeconstants}},
\code{\link{mlr_pipeops_scalemaxabs}},
\code{\link{mlr_pipeops_scalerange}},
\code{\link{mlr_pipeops_scale}},
\code{\link{mlr_pipeops_select}},
\code{\link{mlr_pipeops_smote}},
\code{\link{mlr_pipeops_spatialsign}},
\code{\link{mlr_pipeops_subsample}},
\code{\link{mlr_pipeops_targetinverter}},
\code{\link{mlr_pipeops_targettrafoscalerange}},
\code{\link{mlr_pipeops_targettrafosimple}},
\code{\link{mlr_pipeops_textvectorizer}},
\code{\link{mlr_pipeops_threshold}},
\code{\link{mlr_pipeops_unbranch}},
\code{\link{mlr_pipeops_updatetarget}},
\code{\link{mlr_pipeops_yeojohnson}},
\code{\link{mlr_pipeops}}
}
\concept{PipeOps}
\concept{mlr3pipelines backend related}
